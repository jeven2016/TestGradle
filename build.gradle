//apply the dependencies defined in the customized plugin and then the sub projects can access them
apply from: 'dependencies.gradle'

/**
 * Apply global settings to all projects
 */
allprojects {
  apply plugin: 'java'
//    apply plugin: 'groovy'
  apply plugin: 'maven'
  apply plugin: 'eclipse'
  apply plugin: 'idea'
  apply plugin: 'jacoco'
  apply plugin: 'pmd'
  apply plugin: 'checkstyle'
  apply plugin: 'findbugs'
//    apply plugin: 'org.sonarqube'

  sourceCompatibility = projectInfo.sourceCompatibility
  targetCompatibility = projectInfo.targetCompatibility

  group = projectInfo.group
  version = projectInfo.version

}

subprojects { subpro ->
  String folders = project.property('custom.project.folders')
  String[] paths = subpro.path.split(':');//split the path with colon
  String subproName = paths.last();

  //ignore the project folders since they aren't real gradle projects
  if (folders?.contains(subproName)) {
    println "info: ${subproName} is ignored to apply default settings."
    return;
  }

  [compileJava, compileTestJava, javadoc]*.options*.encoding = 'UTF-8'

  buildscript {
    repositories {
      mavenLocal() //firstly try to retrieve jars from local maven repository
      maven {
        //then try to retrieve jars from nexus
        url nexusPublicUrl
      }
      jcenter()
    }

    dependencies {
      classpath libs.'spring-boot-gradle-plugin'
      classpath libs.'dependency-management-plugin'
      classpath libs.'spring-cloud-contract-gradle-plugin'
    }
  }

  repositories {
    mavenLocal() //firstly try to retrieve jars from local maven repository
    maven {
      //then try to retrieve jars from nexus
      url nexusPublicUrl
    }
  }

  configurations {
    //exclude commons-loggin since we use logback+slf4j libs
    all*.exclude module: 'commons-logging'
  }


  task wrapper(type: Wrapper) {
    gradleVersion = '4.4.1'
  }

  task listJars(description: 'Display all dependencies.') {
    doLast {
      configurations.compile.each { File file -> println "\t" + file.name }
    }
  }

/**
 * Configuration for checkstyle, the google checks file is applied by default
 */
  checkstyle {
    toolVersion = "7.8.1"
    sourceSets = [sourceSets.main]
    configFile = project(":").file('config/checkstyle/google_checks.xml')
    ignoreFailures = true
    showViolations = true
  }

//the test code is ignored
  checkstyleTest {
    enabled = false
  }

  tasks.withType(Checkstyle) {
    reports {
      xml.enabled false
      html.enabled true
    }
  }

/**
 * Configuration for FindBugs
 */
  findbugs {
    toolVersion = "3.0.1"
    ignoreFailures = true
    findbugsTest.enabled = false
    sourceSets = [sourceSets.main]
    effort = "max"
  }

  tasks.withType(FindBugs) {
    reports {
      xml.enabled = false
      html.enabled = true
    }
  }

/**
 * Configuration for PMD
 */
  pmd {
    toolVersion = '6.0.0'
    ignoreFailures = true
    pmdTest.enabled = false
    ruleSetFiles = project(":").files("config/pmd/pmd-rulesets.xml")
  }

  tasks.withType(Pmd) {
    reports {
      xml.enabled = false
      html.enabled = true
    }
  }

/**
 * Configuration for Jacoco
 */
  jacoco {
    toolVersion = "0.8.0"
  }

  jacocoTestReport {
    group = "Reporting"
    reports {
      xml.enabled false
      html.enabled true
      html.destination project(":").file("${buildDir}/reports/coverage")
    }
  }

  check.dependsOn jacocoTestReport

  /**
   * Configuration for sonarqube
   */
//    sonarqube {
//        properties {
//            property "sonar.java.coveragePlugin", "jacoco"
//            property "sonar.exclusion", "src/main/resources/**"
//            property "sonar.projectName", rootProject.name
//            property "sonar.projectVersion", "${projectInfo.version}"
//            property "onar.jacoco.reportPaths", "${buildDir}/jacoco/test.exec"
//            property "sonar.exclusions", "build/**/*"
//        }
//    }
//    project.tasks["sonarqube"].dependsOn build


  jar {
    baseName = project(":").name
    manifest {
      attributes 'Implementation-Title': project(":").name,
          'Implementation-Version': projectInfo.version
    }
  }

  /**
   * The task to generate a sources jar
   */
  task sourcesJar(type: Jar, dependsOn: classes) {
    classifier = 'sources'
    from sourceSets.main.allSource
  }

  /**
   * The task to generate a javadoc jar
   */
  task javadocJar(type: Jar, dependsOn: javadoc) {
    classifier = 'javadoc'
    from javadoc.destinationDir
  }

  artifacts {
    archives jar
//    archives sourcesJar
//    archives javadocJar
  }

  /**
   * Build a docker image: cdc/iotgw:version
   */
  task buildDocker(type: Exec) {
    doFirst {
      copy {
        from("docker/") {
          include '**'
        }
        into("${buildDir}/libs")
      }
    }
    workingDir "${buildDir}/libs"

    //build a latest docker image
    commandLine 'docker', 'build', '-t', "mbdslc/${project(":").name}:latest", '.'

    dependsOn build
  }


}
